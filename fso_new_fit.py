# -*- coding: utf-8 -*-
"""FSO_new_fit.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dff4-2iRC8nDgYCnj5ViAzXXj_-EaxDq
"""

import sncosmo
import sfdmap
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import numpy as np
import astropy
from astropy.table import Table
from astropy import constants
import requests
import seaborn as sns
import json
from pydantic import BaseModel
from typing import Literal, List, Dict
import math
from sklearn.metrics import mean_squared_error

import time
import selenium
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from sncosmo.fitting import DataQualityError


snadoid_to_tbound = {
    228 : [58300, 58350],
    116 : [58330, 58360],
    135 : [58300, 58350],
    157 : [58290, 58340],
    229 : [58230, 58280],
    211 : [58625, 58675],
    238 : [58300, 58350],
}

class Observation(BaseModel):
    mjd: float
    flux: float
    fluxerr: float
    zp: float = 8.9
    zpsys: Literal['ab', 'vega'] = 'ab'
    band: str

class Target(BaseModel):
    light_curve: List[Observation]
    ebv: float
    t_min: float
    t_max: float
    count: int
    name_model: str
    redshift: List[float]

class Point(BaseModel):
    time: float
    flux: float
    band: str

class Result(BaseModel):
    flux_jansky: List[Point]
    degrees_of_freedom: int
    covariance: List[List[float]]
    mse:float
    parameters: Dict[str, float]


def fit(data, name_model, ebv, redshift, snadid, t_min, t_max):
    dust = sncosmo.CCM89Dust()
    model = sncosmo.Model(source=name_model, effects=[dust], effect_names=['mw'], effect_frames=['obs'])
    model.set(mwebv=ebv)
    snadid = int(snadid[4:])
    try:
        if snadid in snadoid_to_tbound.keys():
            print(snadid)
            first_result,first_fit_model = sncosmo.fit_lc(data, model, ['z', 't0', 'amplitude'], #guess_z=True,
                                                   bounds={'z':(redshift[0], redshift[1]),
                                                           't0':(snadoid_to_tbound[snadid][0], snadoid_to_tbound[snadid][1])})
            res = sncosmo.mcmc_lc(data, first_fit_model, ['z', 't0', 'amplitude'], guess_z=False, guess_t0=False,
                                                   bounds={'z': (redshift[0], redshift[1]),
                                                           't0': (snadoid_to_tbound[snadid][0], snadoid_to_tbound[snadid][1])
                                                           #,'amplitude': (1.0e-12, 1.0e-7)
                                                          })

        else:
            first_result,first_fit_model = sncosmo.fit_lc(data, model, ['z', 't0', 'amplitude'], #guess_z=True,
                                                   bounds={'z':(redshift[0], redshift[1]),
                                                           })
            res = sncosmo.mcmc_lc(data, first_fit_model, ['z', 't0', 'amplitude'], guess_z=False, guess_t0=False,
                                                   bounds={'z': (redshift[0], redshift[1])
                                                          #,'amplitude': (1.0e-12, 1.0e-7)
                                                          }
                                                  )
        #print(type(res[0]))

    except DataQualityError as d:
        print('DataQualityError')
        df = pd.DataFrame({'name' : snadid, 'model' : name_model, 'error' : 'DataQualityError', 'text' : str(d)})
        df.to_csv('id_exception_v25.csv', mode='a', index= False, header=False)
        return {'error' : 'DataQualityError'}
    except RuntimeError as r:
        print('RuntimeError')
        df = pd.DataFrame([{'name' : snadid, 'model' : name_model, 'error' : 'RuntimeError', 'text' : str(r)}])
        df.to_csv('id_exception_v25.csv', mode='a', index= False, header=False)
        return {'error' : 'RuntimeError'}
    return res


def get_flux_and_params(summary, data, fitted_model, t_min, t_max, count):

    segment = np.linspace(t_min, t_max, count)
    df = data.to_pandas()
    points = []
    mse = 0
    for band in df['band'].unique():
        predicts = fitted_model.bandflux(band, segment, df['zp'][0], df['zpsys'][0])
        points += [Point(time=time, flux=flux, band=band) for time, flux in zip(segment, predicts)]
        df['predicts'] = fitted_model.bandflux(band, sorted(df['mjd']), df['zp'][0], df['zpsys'][0])
        mse += mean_squared_error(df['flux'], df['predicts'])
    try: cov=summary.covariance.tolist()
    except:
        cov=[[]]
        print('covariance is none')
    #d_param = dict(summary.param_dict)
    return Result(flux_jansky=points, parameters=dict(zip(summary.param_names, summary.parameters)),
                       degrees_of_freedom=summary.ndof, covariance=cov, mse=mse)


def approximate(data: Target, snadid):

    df = pd.DataFrame([obs.model_dump() for obs in data.light_curve])
    table = Table.from_pandas(df)
    fit_data = fit(table, data.name_model, data.ebv, data.redshift, snadid, data.t_min, data.t_max)
    try: summary, fitted_model = fit_data
    except ValueError: return fit_data
    result = get_flux_and_params(summary, table, fitted_model, data.t_min, data.t_max, data.count)
    return result


oid_to_tmax = { # время максимума только для графика, фит строится
    169 : 58572.42763, 204 : 58605.40540, 241 : 58231.36666, 211 : 58647.32578, 238 : 58324.20177, 186 : 58198.38628,
    234 : 58224.44818, 152 : 58222.30126, 110 : 58269.19916, #228 : 58326
}


def plot(curves: Result, data, oid_namemodel, t_l, t_r):
    band_color = {'ztfr' : 'r', 'ztfg' : 'g', 'ztfi' : 'm'}
    mjd_offset = 58000
    data_r = data[data['band']=='ztfr']
    data_g = data[data['band']=='ztfg']
    if data_r.shape[0]>data_g.shape[0]:
        data_max = data_r
    else: data_max = data_g
    #key = int(oid_namemodel[4:7])
    #if key in oid_to_tmax.keys(): t_max_mag = oid_to_tmax[key] - mjd_offset
    #else: t_max_mag = data_max[data_max['mag']==data_max['mag'].min()]['mjd'].values[0] - mjd_offset
    t_l -= mjd_offset
    t_r -= mjd_offset
    data = data[((data['mjd'] - mjd_offset >= t_l) & (data['mjd'] - mjd_offset <= t_r))]
    print('Uniq band', data['band'].unique())
    curve = pd.DataFrame([obs.model_dump() for obs in curves.flux_jansky])
    fig, axs = plt.subplots(1, len(data['band'].unique()), figsize=(16,5))
    axs = np.array(axs)
    plt.suptitle(oid_namemodel, fontsize=20)
    it = 0
    for it, ax_band in enumerate(zip(axs.reshape(-1), sorted(data['band'].unique(),
                                                             key = lambda x: 1 if x[-1]=='g' else (2 if x[-1]=='r' else 3)))):
        ax, band = ax_band[0], ax_band[1]
        data_band = data[data['band']==band]
        curve_band = curve[curve['band']==band]
        flux_max = max(data['flux'].max(), curve_band['flux'].max())
        flux_min = min(data['flux'].min(), curve_band['flux'].min())
        ax.set_xlim([t_l, t_r])
        ax.set_ylim([-5+flux_min*10**6, flux_max*10**6+10])
        ax.errorbar(data_band['mjd']-mjd_offset, data_band['flux'] * 10**6, yerr=data_band['fluxerr'] * 10**6, fmt="o", color=band_color[band], elinewidth=1, marker='.', label=band)
        ax.plot(curve_band['time']-mjd_offset, curve_band['flux'] * 10**6, color=band_color[band])
        ax.set_xlabel("MJD-58000", fontsize=16)
        ax.grid(which='major')
        matplotlib.rc('xtick', labelsize=15)
        ax.legend(prop={"size":16})
        if it==0:
            ax.set_ylabel("Flux, " + "μ" + "Jy", fontsize=16)
            matplotlib.rc('ytick', labelsize=15)
        plt.savefig('Lom/' + oid_namemodel)
    plt.show()


def task(oid, list_models, count, redshift):
    data = pd.read_csv('data_calc_ref/' + str(oid) + '.csv')
    snadid = data['Name'][0]
    oid_ebv = pd.read_csv('oid_ebv.csv')
    ebv = float(list(oid_ebv[oid_ebv['OID'] == oid]['ebv'])[0])
    data_r = data[data['band']=='ztfr']
    data_g = data[data['band']=='ztfg']
    if data_r.shape[0]>data_g.shape[0]:
        data_max = data_r
    else: data_max = data_g
    #t_max_mag = data_max[data_max['mag']==data_max['mag'].min()]['mjd'].values[0]
    #try: t_max_mag = oid_to_tmax_plot[int(snadid[4:7])]
    #except KeyError: t_max_mag = data_max[data_max['mag']==data_max['mag'].min()]['mjd'].values[0]
    #t_min = t_max_mag - 30
    #t_max = t_max_mag + 120
    key = int(snadid[4:7])
    if key in oid_to_tmax.keys(): t_max_mag = oid_to_tmax[key] #- mjd_offset
    else: t_max_mag = data_max[data_max['mag']==data_max['mag'].min()]['mjd'].values[0] #- mjd_offset
    max_mag = data_max['mag'][data['mjd']==t_max_mag].values[0]
    print(max_mag)
    if max_mag>=21:
        redshift = [0.035,0.65] # [-15,-22] for 21 mag
    elif max_mag>=20:
        redshift = [0.025,0.45] # [-15,-22] for 20 mag
    elif max_mag>=19:
        redshift = [0.015,0.30] # [-15,-22] for 19 mag
    #redshift = [0.01,0.65]
    print(redshift)
    t_l = t_max_mag - 30
    t_r = t_max_mag + 120
    data = data[(data['band']=='ztfr') | (data['band']=='ztfg')]
    data['zp'] = 8.9
    data['zpsys'] = 'ab'
    data.drop(['Unnamed: 0', 'magerr', 'clrcoeff', 'oid', 'flux', 'fluxerr', 'ref', 'referr', 'Name'], axis= 1 , inplace= True)
    data = data.rename(columns={'flux_dif': 'flux', 'flux_dif_err': 'fluxerr'})
    data.dropna()
    json_flux_dif = data.to_dict('records')
    result_list = []
    for model in list_models:
        curves = approximate(Target(light_curve=[Observation(mjd=obs['mjd'], flux=obs['flux'], fluxerr=obs['fluxerr'],
                                                             band=obs['band'], zp=obs['zp'], zpsys=obs['zpsys'])
                                          for obs in json_flux_dif], ebv=ebv, name_model=model, t_min=t_l, t_max=t_r,
                                    count=count, redshift=redshift), snadid)
        try: plot(curves, data, str(snadid)+'_'+model, t_l, t_r)
        except AttributeError:
            res = -1
        try:
            z = curves.parameters['z']
            m_abs_max = data_r['mag'].min() - astropy.cosmology.Planck18.distmod(z).value
            res = {'name' : snadid, 'model' : model, 'M' : m_abs_max, 'mse' : curves.mse, 'z' : z,
                    't0' : curves.parameters['t0'], 'amplitude' : curves.parameters['amplitude'], 'mwebv' : curves.parameters['mwebv'],
                    'mwr_v' : curves.parameters['mwr_v'], 'max_mag' : max_mag}
        except AttributeError:
            print(res, 'AttributeError')
            res = -1
        if type(res) is dict:
            result_list.append(res)
    result_list.sort(key=lambda x: x['mse'])
    df_result = pd.DataFrame(result_list)
    print(df_result)
    df_result.to_csv('id_result_z_v16.csv', mode='a', index= False, header=False)
    return result_list


def get_best_fit(oid, list_models, t_min, t_max, count, redshift):
    result_list = []
    for model in list_models:
        res = task(oid, model, t_min, t_max, count, redshift)
        if type(res) is dict: result_list.append(res)
    result_list.sort(key=lambda x: x['chi2'])
    print(result_list)


#list_nugent = ['nugent-sn1a', 'nugent-sn91t', 'nugent-sn91bg', 'nugent-sn1bc', 'nugent-hyper', 'nugent-sn2n', 'nugent-sn2l', 'nugent-sn2p']
list_nugent = ['nugent-sn1a', 'nugent-sn1bc', 'nugent-sn2n', 'nugent-sn2l', 'nugent-sn2p']

objects = pd.read_csv('snad_catalog.csv')
objects = objects[objects['Type']=='PSN']
objects = pd.concat([objects[objects['Name'].apply(lambda x: int(x[4:]))==108], objects[objects['Name'].apply(lambda x: int(x[4:]))==111],
    objects[objects['Name'].apply(lambda x: int(x[4:]))==112]])
print(objects)
for oid in objects['OID']:
    task(oid, list_nugent, 3000, [0.01, 0.65])

objects = pd.read_csv('snad_catalog.csv')
objects = objects[objects['Type']=='PSN']
objects = objects[objects['Name'].apply(lambda x: int(x[4:]))>=101]
print(objects)
for oid in objects['OID']:
    task(oid, list_nugent, 3000, [0.01, 0.3])

import pandas as pd
df = pd.DataFrame(columns=['name', 'model', 'M', 'chi2', 'z', 't0', 'amplitude', 'mwebv', 'mwr_v', 'max_mag'])
df.to_csv('result_z_v11.csv', mode='a', index= False)
results = pd.read_csv('id_result_z_v11.csv')
for obj in results['name'].unique():
    df_obj = results[results['name']==obj].sort_values(by='chi2')
    #df_obj.drop(['z', 't0', 'amplitude', 'mwebv', 'mwr_v'], axis= 1 , inplace= True)
    df_obj = df_obj.head(1)
    df_obj.to_csv('result_z_v11.csv', mode='a', index= False, header=False)

import pandas as pd
df = pd.DataFrame(columns=['name', 'model', 'M', 'mse', 'z', 't0', 'amplitude', 'mwebv', 'mwr_v', 'max_mag'])
df.to_csv('result_z_v12.csv', mode='a', index= False)
results = pd.read_csv('id_result_z_v12.csv')
for obj in results['name'].unique():
    df_obj = results[results['name']==obj].sort_values(by='mse')
    #df_obj.drop(['z', 't0', 'amplitude', 'mwebv', 'mwr_v'], axis= 1 , inplace= True)
    df_obj = df_obj.head(1)
    df_obj.to_csv('result_z_v12.csv', mode='a', index= False, header=False)

import pandas as pd
import matplotlib.pyplot as plt
df = pd.read_csv('id_result_z_v16.csv')
df = df[(abs(df['z']-0.035)<0.001) | (abs(df['z']-0.65)<0.001)| (abs(df['z']-0.025)<0.001)| (abs(df['z']-0.45)<0.001)
        | (abs(df['z']-0.015)<0.001) | (abs(df['z']-0.30)<0.001)]
#[0.035,0.65]
#[0.025,0.45]
#[0.015,0.30]
df = df.reset_index()
print(df)
df['model'] = [mod[7:] for mod in df['model']]
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,5))
ax1.hist(df['max_mag'])
ax2.hist(df['model'])
plt.show()
print(df['name'].unique())

df = pd.read_csv('id_result_z_v12.csv')
df = df[(abs(df['z']-0.035)<0.001) | (abs(df['z']-0.65)<0.001)| (abs(df['z']-0.025)<0.001)| (abs(df['z']-0.45)<0.001)
        | (abs(df['z']-0.015)<0.001) | (abs(df['z']-0.30)<0.001)]
df = df.reset_index()
print(df)
df['model'] = [mod[7:] for mod in df['model']]
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,5))
ax1.hist(df['max_mag'])
ax2.hist(df['model'])
plt.show()
print(df['name'].unique())

df = pd.DataFrame(columns=['name', 'model', 'error', 'text'])
df.to_csv('id_exception_v25.csv', mode='a', index= False)
df = pd.DataFrame(columns=['name', 'model', 'M', 'mse', 'z',
                    't0', 'amplitude', 'mwebv','mwr_v', 'max_mag'])
df.to_csv('id_result_z_v16.csv', mode='a', index= False)

import pandas as pd
df = pd.DataFrame(columns=['name', 'model', 'M', 'mse', 'z', 't0', 'amplitude', 'mwebv', 'mwr_v', 'max_mag'])
df.to_csv('result_z_v16.csv', mode='a', index= False)
results = pd.read_csv('id_result_z_v16.csv')
for obj in results['name'].unique():
    df_obj = results[results['name']==obj].sort_values(by='mse')
    #df_obj.drop(['z', 't0', 'amplitude', 'mwebv', 'mwr_v'], axis= 1 , inplace= True)
    df_obj = df_obj.head(1)
    df_obj.to_csv('result_z_v16.csv', mode='a', index= False, header=False)

#Сравнение с Pruzhinskaya_2023
import pandas as pd
import numpy as np


def chek(filename):
    df1 = pd.read_csv('snad_objects_Pruzhinskaya_2023.txt', sep=' ')
    df1 = df1[['Name', 'Type']]
    df1['Type'] = df1['Type'].apply(lambda x: str(x))#.lower())
    df2 = pd.read_csv(filename)
    df2 = df2[['name', 'model']]
    df2['model'] = df2['model'].apply(lambda x:
                                      str(x[9:]).replace('2', 'II').replace('1', 'I').replace('p', 'P').replace('l', 'L'))
    res = df1.set_index('Name').join(df2.set_index('name'))
    res['check'] = [i==j if str(j)!='nan' else j for i, j in  zip(res['Type'], res['model'])]
    #res.drop_duplicates(subset=[])
    res = res[~res.index.duplicated()].copy()
    print(res)
    print('% correct', float(res[res['check']==True].shape[0])/
          (res[res['check']==True].shape[0] + res[res['check']==False].shape[0])*100)

chek('result_z_v16.csv')
chek('result_z_v12.csv')

